import { escapeLatex, escapeLatexUrl, processBodyText } from './escaper';
import type { DocumentData, Reference, Enclosure, Paragraph, CopyTo } from '@/types/document';
import { DOC_TYPE_CONFIG } from '@/types/document';

interface DocumentStore {
  docType: string;
  formData: Partial<DocumentData>;
  references: Reference[];
  enclosures: Enclosure[];
  paragraphs: Paragraph[];
  copyTos: CopyTo[];
}

// const PARAGRAPH_INDENT_SPACES = 4; // Used in getBodyText for plain text output

function getParagraphLabel(level: number, count: number): string {
  const patterns = [
    (n: number) => `${n}.`,
    (n: number) => `${String.fromCharCode(96 + n)}.`,
    (n: number) => `(${n})`,
    (n: number) => `(${String.fromCharCode(96 + n)})`,
  ];
  const pattern = patterns[level % 4];
  return pattern(count);
}

function calculateLabels(paragraphs: Paragraph[]): string[] {
  const labels: string[] = [];
  const counters = [0, 0, 0, 0, 0, 0, 0, 0];

  for (const para of paragraphs) {
    for (let i = para.level + 1; i < 8; i++) {
      counters[i] = 0;
    }
    counters[para.level]++;
    labels.push(getParagraphLabel(para.level, counters[para.level]));
  }

  return labels;
}

// getBodyText is used for plain text output (not LaTeX)
// Keeping for potential future use in exports
// function getBodyText(paragraphs: Paragraph[]): string {
//   const labels = calculateLabels(paragraphs);
//   return paragraphs
//     .map((para, i) => {
//       const indent = ' '.repeat(para.level * PARAGRAPH_INDENT_SPACES);
//       return `${indent}${labels[i]}  ${para.text}`;
//     })
//     .join('\n\n');
// }

export function generateDocumentTex(store: DocumentStore): string {
  const data = store.formData;
  // config will be used for document-type specific variations
  const _config = DOC_TYPE_CONFIG[store.docType] || DOC_TYPE_CONFIG.naval_letter;
  void _config;

  let tex = `%=============================================================================
% DOCUMENT CONFIGURATION - Generated by libo-secured
%=============================================================================

\\setDocumentType{${store.docType}}
\\setFontSize{${data.fontSize || '12pt'}}
\\setFontFamily{${data.fontFamily || 'courier'}}
\\setPageNumbering{${data.pageNumbering || 'none'}}

`;

  // Standard configuration
  tex += `\\setSSIC{${escapeLatex(data.ssic)}}
\\setSerial{${escapeLatex(data.serial)}}
\\setDocumentDate{${escapeLatex(data.date)}}

\\setFrom
    {${escapeLatex(data.from)}}
    {}{}{}

\\setTo
    {${escapeLatex(data.to)}}
    {}{}{}

${data.via?.trim() ? `\\setVia
    {${escapeLatex(data.via?.split('\n')[0] || '')}}
    {${escapeLatex(data.via?.split('\n')[1] || '')}}
    {${escapeLatex(data.via?.split('\n')[2] || '')}}
    {${escapeLatex(data.via?.split('\n')[3] || '')}}` : '% No Via'}

\\setSubject{${escapeLatex(data.subject)}}

\\setBusinessSalutation{Dear Sir or Madam:}
\\setBusinessClose{Very respectfully,}

\\setPOC{${escapeLatex(data.pocEmail)}}
`;

  return tex;
}

export function generateLetterheadTex(store: DocumentStore): string {
  const data = store.formData;

  return `%=============================================================================
% LETTERHEAD CONFIGURATION - Generated by libo-secured
%=============================================================================

% Seal type: dod (current) or dow (historical Department of War)
\\setSealType{${data.sealType || 'dod'}}

\\setLetterhead
    {${escapeLatex(data.unitLine1)}}
    {${escapeLatex(data.unitLine2)}}
    {${escapeLatex(data.unitAddress?.split(',')[0] || '')}}
    {${escapeLatex(data.unitAddress?.split(',').slice(1).join(',').trim() || '')}}
`;
}

export function generateSignatoryTex(store: DocumentStore): string {
  const data = store.formData;

  const fullName = [data.sigFirst, data.sigMiddle, data.sigLast?.toUpperCase()]
    .filter(Boolean)
    .join(' ');

  const abbrevName = [
    data.sigFirst?.[0] ? `${data.sigFirst[0]}.` : '',
    data.sigMiddle?.[0] ? `${data.sigMiddle[0]}.` : '',
    data.sigLast?.toUpperCase() || '',
  ]
    .filter(Boolean)
    .join(' ');

  let byDirectionTex = '';
  if (data.byDirection) {
    const authority = data.byDirectionAuthority || 'the Commanding Officer';
    byDirectionTex = `\\setByDirection{By direction of ${escapeLatex(authority)}}`;
  }

  return `%=============================================================================
% SIGNATURE CONFIGURATION - Generated by libo-secured
%=============================================================================

\\setSignatory
    {${escapeLatex(data.sigFirst)}}
    {${escapeLatex(data.sigMiddle)}}
    {${escapeLatex(data.sigLast)}}
    {${escapeLatex(data.sigRank)}}
    {${escapeLatex(data.sigTitle)}}

\\setSignatoryName{${escapeLatex(fullName)}}
\\setSignatoryAbbrev{${escapeLatex(abbrevName)}}

${byDirectionTex}

\\setSignatureImage{}
`;
}

export function generateFlagsTex(store: DocumentStore): string {
  let flags = '% Flags - Generated by libo-secured\n';
  if (store.references.length > 0) {
    flags += '\\setHasReferences\n';
  }
  if (store.enclosures.length > 0) {
    flags += '\\setHasEnclosures\n';
  }
  return flags;
}

export function generateReferencesTex(store: DocumentStore): string {
  if (store.references.length === 0) {
    return '% No references\n';
  }

  return `%=============================================================================
% REFERENCES - Generated by libo-secured
% Count: ${store.references.length} references
%=============================================================================

${store.references.map((r) => `\\refitem{${r.letter}}{${escapeLatex(r.title)}}`).join('\n')}
`;
}

export function generateReferenceUrlsTex(store: DocumentStore): string {
  const refsWithUrls = store.references.filter((r) => r.url?.trim());
  if (refsWithUrls.length === 0) return '% No reference URLs\n';

  return `%=============================================================================
% REFERENCE URLS - Generated by libo-secured
%=============================================================================

${refsWithUrls.map((r) => `\\setRefURL{${r.letter}}{${escapeLatexUrl(r.url)}}`).join('\n')}
`;
}

export function generateEnclosuresTex(store: DocumentStore): string {
  if (store.enclosures.length === 0) {
    return '% No enclosures\n';
  }

  return `%=============================================================================
% ENCLOSURES - Generated by libo-secured
% Count: ${store.enclosures.length} enclosures
%=============================================================================

${store.enclosures
    .map((e, i) => {
      const filename = e.file ? 'JSPDF' : '';
      return `\\enclosure{${i + 1}}{${filename}}{${escapeLatex(e.title || 'Untitled')}}`;
    })
    .join('\n')}
`;
}

export function generateCopyToTex(store: DocumentStore): string {
  if (store.copyTos.length === 0) {
    return '% No copy-to recipients\n';
  }

  return `%=============================================================================
% COPY TO (DISTRIBUTION) - Generated by libo-secured
% Count: ${store.copyTos.length} recipients
%=============================================================================

\\setCopyTo
${store.copyTos.map((ct, i) => `\\copytoentry{${i + 1}}{${escapeLatex(ct.text)}}`).join('\n')}
`;
}

export function generateBodyTex(store: DocumentStore): string {
  const labels = calculateLabels(store.paragraphs);

  let latex = `%=============================================================================
% DOCUMENT BODY - Generated by libo-secured
%=============================================================================

`;

  let openLevels: number[] = [];

  for (let i = 0; i < store.paragraphs.length; i++) {
    const para = store.paragraphs[i];
    const label = labels[i];

    // Close environments if level changes
    if (openLevels.length > 0 && openLevels[openLevels.length - 1] !== para.level) {
      const closingLevel = openLevels.pop()!;
      latex += getCloseEnvironment(closingLevel) + '\n\n';
    }

    if (para.level === 0) {
      latex += `\\vspace{12pt}\n\\noindent ${label}  ${processBodyText(para.text)}\n\n`;
    } else {
      if (openLevels.length === 0) {
        latex += getOpenEnvironment(para.level) + '\n';
        openLevels.push(para.level);
      }
      latex += `\\item ${processBodyText(para.text)}\n\n`;
    }
  }

  // Close remaining environments
  while (openLevels.length > 0) {
    const closingLevel = openLevels.pop()!;
    latex += getCloseEnvironment(closingLevel) + '\n';
  }

  return latex;
}

function getOpenEnvironment(level: number): string {
  switch (level) {
    case 1: return '\\begin{subpara}';
    case 2: return '\\begin{subsubpara}';
    case 3: return '\\begin{subsubsubpara}';
    case 4: return '\\begin{subsubsubsubpara}';
    case 5: return '\\begin{subsubsubsubsubpara}';
    case 6: return '\\begin{subsubsubsubsubsubpara}';
    case 7: return '\\begin{subsubsubsubsubsubsubpara}';
    default: return '\\begin{subpara}';
  }
}

function getCloseEnvironment(level: number): string {
  switch (level) {
    case 1: return '\\end{subpara}';
    case 2: return '\\end{subsubpara}';
    case 3: return '\\end{subsubsubpara}';
    case 4: return '\\end{subsubsubsubpara}';
    case 5: return '\\end{subsubsubsubsubpara}';
    case 6: return '\\end{subsubsubsubsubsubpara}';
    case 7: return '\\end{subsubsubsubsubsubsubpara}';
    default: return '\\end{subpara}';
  }
}

export function generateClassificationTex(store: DocumentStore): string {
  const data = store.formData;

  if (data.classLevel === 'unclassified' || !data.classLevel) {
    return '% Unclassified - no classification markings\n';
  }

  if (data.classLevel === 'cui') {
    return `%=============================================================================
% CUI CONFIGURATION - Generated by libo-secured
%=============================================================================

\\setCUI
\\setCUIControlledBy{${escapeLatex(data.cuiControlledBy)}}
\\setCUICategory{${escapeLatex(data.cuiCategory)}}
\\setCUIDissemination{${escapeLatex(data.cuiDissemination)}}
\\setCUIDistStatement{${escapeLatex(data.cuiDistStatement)}}
\\setPOC{${escapeLatex(data.pocEmail)}}
`;
  }

  const classLevelMap: Record<string, string> = {
    confidential: 'CONFIDENTIAL',
    secret: 'SECRET',
    top_secret: 'TOP SECRET',
    top_secret_sci: 'TOP SECRET//SCI',
  };

  return `%=============================================================================
% CLASSIFICATION CONFIGURATION - Generated by libo-secured
%=============================================================================

\\setClassification{${classLevelMap[data.classLevel] || 'SECRET'}}
\\setClassifiedBy{${escapeLatex(data.classifiedBy)}}
\\setDerivedFrom{${escapeLatex(data.derivedFrom)}}
\\setDeclassifyOn{${escapeLatex(data.declassifyOn)}}
\\setClassificationReason{${escapeLatex(data.classReason)}}
\\setPOC{${escapeLatex(data.classifiedPocEmail)}}
`;
}

export function generateAllLatexFiles(store: DocumentStore): Record<string, string> {
  return {
    'config/document.tex': generateDocumentTex(store),
    'config/letterhead.tex': generateLetterheadTex(store),
    'config/signatory.tex': generateSignatoryTex(store),
    'config/flags.tex': generateFlagsTex(store),
    'config/references.tex': generateReferencesTex(store),
    'config/reference-urls.tex': generateReferenceUrlsTex(store),
    'config/encl-config.tex': generateEnclosuresTex(store),
    'config/copyto-config.tex': generateCopyToTex(store),
    'config/body.tex': generateBodyTex(store),
    'config/classification.tex': generateClassificationTex(store),
  };
}
